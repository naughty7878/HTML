<!DOCTYPE html>
<html>
<head>
	<title>原型prototype</title>
</head>
<body>
	<script type="text/javascript">
		/*
		原型prototype
			* 由于js是解析执行的语言，那么代码在出现函数与对象重复执行，会创建多个副本
			* 传统的构造方法中，对象的方法写在构造方法中，就会重复执行，优化把方法提出来，放发外面；隐患与其他库可能产生冲突
		任意一个对象都会默认的链接到它的原型中
			* 创建一个函数，会附带的创建一个特殊的对象。该对象使用 函数.proptotype 引用	,称其为函数的原型属性
			* 每一个由该函数作为构造函数创建的对象，都会默认的链接到该对象中
			* 在该对象访问一个方法或属性的时候，如果该对象中没有，就会到这个神秘对象中查找
		原型相关的概念
		1、关于面向对象的概念
			* 类class： 在js中就是构造函数，在传统的面向对象语言中，使用一个叫类的东西定义模板，然后使用模板创建对象，在构造方法中也具有类似的功能，因此也称其为类
			* 实例（instance）与对象（object）：实例是指某一个构造函数创建出来的对象。我们说XXX 构造函数的实例，实例就是对象，对象是一个泛称，实例与对象是一个近义词
			* 键值对与属性和方法：在js中键值对的集合称为对象，如果值为数据（非函数），就称该键值对为属性property，如果值为函数（方法），就称该键值对为方法method。
			* 父类与子类：传统的面向对象语言中使用类来实现继承，那么就有父类和子类的概念，父类又称为基类，子类又称为派生类；在js中常常称为父对象，子对象，基对象，派生对象。
		2、原型相关的概念
			* 神秘对象针对构造函数称为“原型属性”，简称原型
			* 神秘对象与构造函数创建出来的对象也有一定关系，神秘对象针对构造函创建出来的对象称为“原型对象”，简称原型
			* 对象继承自原型：构造函数创建的对象继承自-构造函数的原型属性或该对象的原型对象；构造函数所创建出来的对象与构造函数的原型属性表示对象是两个不同的对象，原型中的成员，可以直接被实例对象所使用，也就是说实例对象“含有”原型中的成员。这就是原型继承
		
		原型的使用
			1、利用对象的动态特性
				* 构造函数.prototype.XXX = vvvvv;
			2、利用直接替换
				Student.prototype = {
					sayHello: function () {},
					study: function () {}
				}

		原型的访问
			1、使用构造函数访问
				* 构造函数.prototype
			2、使用对象访问
				* 对象.__proto__ 

		原型中默认都有要给属性"constructor",翻译为构造器，表示该原型是与构造函数联系起来的


		其他问题
			* 凡是字面量的对象都有构造函数
				* {} 	Object
				* []	Array
				* /./	RegExp
				* function... 	Function

		


		*/


		var arr = [];
		for (var i = 0; i < 2; i++) {
			arr.push({});
		}

		console.log(arr[0] == arr[1]);//false


		function Person(name, age, gender) {
			this.name = name;
			this.age = age;
			this.gender = gender;
			this.sayHello = function(){
				console.log( '你好');
			};
		}

		var p1 = new Person();
		var p2 = new Person();
		console.log(p1.sayHello == p2.sayHello);//false;

		function Dog(){

		}
		console.log( Dog.prototype) ;
		Dog.prototype.name = 'dog';

		var d1 = new Dog();
		console.log(d1.name);//若果d1没有name ，那么就会到Dog.prototype中找
		console.log(Dog.prototype === d1.__proto__);//指向统一对象
		console.log(d1.__proto__ === d1.constructor.prototype);//指向统一对象

	</script>
</body>
</html>